<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Neural Network Explorer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            overflow-x: hidden;
        }
        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        .header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(10px);
            padding: 20px;
            text-align: center;
        }
        h1 {
            margin: 0;
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .subtitle {
            margin: 5px 0;
            opacity: 0.9;
            font-size: 1.1em;
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .btn-primary {
            background: rgba(74, 144, 226, 0.8);
            border: 2px solid rgba(74, 144, 226, 0.3);
        }
        .btn-primary:hover {
            background: rgba(74, 144, 226, 1);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(74, 144, 226, 0.3);
        }
        .btn-success {
            background: rgba(72, 187, 120, 0.8);
            border: 2px solid rgba(72, 187, 120, 0.3);
        }
        .btn-success:hover {
            background: rgba(72, 187, 120, 1);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(72, 187, 120, 0.3);
        }
        .btn-warning {
            background: rgba(237, 137, 54, 0.8);
            border: 2px solid rgba(237, 137, 54, 0.3);
        }
        .btn-warning:hover {
            background: rgba(237, 137, 54, 1);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(237, 137, 54, 0.3);
        }
        .canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        #networkCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        .info-panel {
            position: absolute;
            top: 100px;
            right: 20px;
            width: 300px;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            z-index: 90;
            transform: translateX(320px);
            transition: transform 0.3s ease;
        }
        .info-panel.show {
            transform: translateX(0);
        }
        .info-panel h3 {
            margin-top: 0;
            color: #4A90E2;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .stat-value {
            font-weight: bold;
            color: #48BB78;
        }
        .explanation {
            position: absolute;
            bottom: 100px;
            left: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            z-index: 90;
            text-align: center;
            transform: translateY(200px);
            transition: transform 0.3s ease;
        }
        .explanation.show {
            transform: translateY(0);
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 50;
            text-align: center;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top: 4px solid #4A90E2;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .help-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 40;
            background: rgba(0,0,0,0.8);
            padding: 30px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß† 3D Neural Network Explorer</h1>
            <div class="subtitle">Watch how AI learns to recognize patterns in 3D space</div>
        </div>

        <div class="canvas-container">
            <canvas id="networkCanvas"></canvas>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <div>Building 3D Neural Network...</div>
        </div>

        <div class="help-text" id="helpText">
            <h2>üéØ Welcome to the Neural Network Factory!</h2>
            <p><strong>Think of this as a 3D decision-making factory:</strong></p>
            <ul style="text-align: left; max-width: 400px; margin: 0 auto;">
                <li>üè≠ <strong>Input Layer:</strong> Raw materials enter here</li>
                <li>‚öôÔ∏è <strong>Hidden Layers:</strong> Processing stations that find patterns</li>
                <li>üì¶ <strong>Output Layer:</strong> Final decision comes out here</li>
                <li>üîó <strong>Connections:</strong> Conveyor belts carrying information</li>
            </ul>
            <p><strong>Controls:</strong> Mouse to rotate ‚Ä¢ Scroll to zoom ‚Ä¢ Click neurons to explore</p>
            <button class="btn-primary" onclick="startExploration()">Start Exploring!</button>
        </div>

        <div class="info-panel" id="infoPanel">
            <h3>üîç Network Status</h3>
            <div class="stat-item">
                <span>Training Progress:</span>
                <span class="stat-value" id="trainingProgress">0%</span>
            </div>
            <div class="stat-item">
                <span>Active Neurons:</span>
                <span class="stat-value" id="activeNeurons">0</span>
            </div>
            <div class="stat-item">
                <span>Accuracy:</span>
                <span class="stat-value" id="accuracy">0%</span>
            </div>
            <div class="stat-item">
                <span>Current Task:</span>
                <span class="stat-value" id="currentTask">Ready</span>
            </div>
            <hr style="border: 1px solid rgba(255,255,255,0.1); margin: 20px 0;">
            <div id="neuronDetails">
                <strong>Click a neuron to see details</strong>
            </div>
        </div>

        <div class="explanation" id="explanation">
            <strong>üéì Understanding Neural Networks</strong><br>
            This is a 3D visualization of how neural networks learn. Each sphere is a "neuron" (decision maker), and the lines are "connections" (information pathways). Watch how data flows from input to output!
        </div>

        <div class="controls">
            <button class="btn-primary" onclick="feedData()">üçé Feed Data</button>
            <button class="btn-success" onclick="startTraining()">üéØ Start Learning</button>
            <button class="btn-warning" onclick="showPrediction()">üîÆ Make Prediction</button>
            <button class="btn-primary" onclick="resetNetwork()">üîÑ Reset</button>
            <button class="btn-success" onclick="toggleInfoPanel()">üìä Stats</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let networkGroup, neurons = [], connections = [];
        let isTraining = false, isAnimating = false;
        let trainingProgress = 0, activeNeuronCount = 0, currentAccuracy = 0;
        let mouseX = 0, mouseY = 0;
        let autoRotate = true;

        // Network architecture
        const layers = [
            { neurons: 4, label: "Input Layer", color: 0x4A90E2, z: -200 },
            { neurons: 6, label: "Hidden Layer 1", color: 0x48BB78, z: -100 },
            { neurons: 4, label: "Hidden Layer 2", color: 0xED8936, z: 0 },
            { neurons: 2, label: "Output Layer", color: 0xE53E3E, z: 100 }
        ];

        // Initialize Three.js scene
        function initScene() {
            const canvas = document.getElementById('networkCanvas');
            const container = canvas.parentElement;

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 300);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Network group
            networkGroup = new THREE.Group();
            scene.add(networkGroup);

            // Build network
            buildNetwork();

            // Mouse controls
            setupControls();

            // Start render loop
            animate();

            // Hide loading
            document.getElementById('loading').classList.add('hidden');
        }

        function buildNetwork() {
            neurons = [];
            connections = [];

            // Create neurons for each layer
            layers.forEach((layer, layerIndex) => {
                const layerNeurons = [];
                const neuronGeometry = new THREE.SphereGeometry(8, 16, 16);
                
                for (let i = 0; i < layer.neurons; i++) {
                    const neuronMaterial = new THREE.MeshPhongMaterial({ 
                        color: layer.color,
                        shininess: 100,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const neuron = new THREE.Mesh(neuronGeometry, neuronMaterial);
                    
                    // Position neurons in a circle for each layer
                    const angle = (i / layer.neurons) * Math.PI * 2;
                    const radius = 50 + (layer.neurons * 5);
                    neuron.position.x = Math.cos(angle) * radius;
                    neuron.position.y = Math.sin(angle) * radius;
                    neuron.position.z = layer.z;
                    
                    neuron.userData = {
                        layerIndex: layerIndex,
                        neuronIndex: i,
                        layer: layer,
                        activation: 0,
                        originalColor: layer.color
                    };
                    
                    neuron.castShadow = true;
                    neuron.receiveShadow = true;
                    
                    networkGroup.add(neuron);
                    layerNeurons.push(neuron);
                }
                
                neurons.push(layerNeurons);
            });

            // Create connections between layers
            for (let layerIndex = 0; layerIndex < layers.length - 1; layerIndex++) {
                const currentLayer = neurons[layerIndex];
                const nextLayer = neurons[layerIndex + 1];
                
                currentLayer.forEach(fromNeuron => {
                    nextLayer.forEach(toNeuron => {
                        createConnection(fromNeuron, toNeuron);
                    });
                });
            }

            // Add layer labels
            addLayerLabels();
        }

        function createConnection(fromNeuron, toNeuron) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array([
                fromNeuron.position.x, fromNeuron.position.y, fromNeuron.position.z,
                toNeuron.position.x, toNeuron.position.y, toNeuron.position.z
            ]);
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.LineBasicMaterial({ 
                color: 0x666666,
                transparent: true,
                opacity: 0.3
            });
            
            const connection = new THREE.Line(geometry, material);
            connection.userData = {
                from: fromNeuron,
                to: toNeuron,
                weight: Math.random() * 2 - 1, // Random weight between -1 and 1
                active: false
            };
            
            networkGroup.add(connection);
            connections.push(connection);
        }

        function addLayerLabels() {
            const loader = new THREE.FontLoader();
            // For simplicity, we'll skip text labels and use geometric indicators
            layers.forEach((layer, index) => {
                const geometry = new THREE.RingGeometry(60 + (layer.neurons * 5), 65 + (layer.neurons * 5), 32);
                const material = new THREE.MeshBasicMaterial({ 
                    color: layer.color,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(geometry, material);
                ring.position.z = layer.z;
                networkGroup.add(ring);
            });
        }

        function setupControls() {
            const canvas = document.getElementById('networkCanvas');
            
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            // Mouse events
            canvas.addEventListener('mousedown', (event) => {
                isDragging = true;
                autoRotate = false;
                previousMousePosition = { x: event.clientX, y: event.clientY };
                
                // Raycast for neuron selection
                const mouse = new THREE.Vector2();
                const rect = canvas.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                
                const neuronMeshes = neurons.flat();
                const intersects = raycaster.intersectObjects(neuronMeshes);
                
                if (intersects.length > 0) {
                    selectNeuron(intersects[0].object);
                }
            });
            
            canvas.addEventListener('mousemove', (event) => {
                if (isDragging) {
                    const deltaMove = {
                        x: event.clientX - previousMousePosition.x,
                        y: event.clientY - previousMousePosition.y
                    };
                    
                    networkGroup.rotation.y += deltaMove.x * 0.01;
                    networkGroup.rotation.x += deltaMove.y * 0.01;
                    
                    previousMousePosition = { x: event.clientX, y: event.clientY };
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // Zoom with mouse wheel
            canvas.addEventListener('wheel', (event) => {
                event.preventDefault();
                camera.position.z += event.deltaY * 0.1;
                camera.position.z = Math.max(150, Math.min(500, camera.position.z));
            });
            
            // Touch events for mobile
            canvas.addEventListener('touchstart', handleTouchStart, false);
            canvas.addEventListener('touchmove', handleTouchMove, false);
        }

        function handleTouchStart(event) {
            if (event.touches.length === 1) {
                previousMousePosition = { 
                    x: event.touches[0].clientX, 
                    y: event.touches[0].clientY 
                };
                autoRotate = false;
            }
        }

        function handleTouchMove(event) {
            event.preventDefault();
            if (event.touches.length === 1) {
                const deltaMove = {
                    x: event.touches[0].clientX - previousMousePosition.x,
                    y: event.touches[0].clientY - previousMousePosition.y
                };
                
                networkGroup.rotation.y += deltaMove.x * 0.01;
                networkGroup.rotation.x += deltaMove.y * 0.01;
                
                previousMousePosition = { 
                    x: event.touches[0].clientX, 
                    y: event.touches[0].clientY 
                };
            }
        }

        function selectNeuron(neuron) {
            // Reset all neurons
            neurons.flat().forEach(n => {
                n.material.color.setHex(n.userData.originalColor);
                n.material.opacity = 0.8;
                n.scale.set(1, 1, 1);
            });
            
            // Highlight selected neuron
            neuron.material.color.setHex(0xffffff);
            neuron.material.opacity = 1;
            neuron.scale.set(1.5, 1.5, 1.5);
            
            // Show neuron details
            showNeuronDetails(neuron);
            
            // Highlight connected neurons
            highlightConnections(neuron);
        }

        function highlightConnections(selectedNeuron) {
            connections.forEach(connection => {
                if (connection.userData.from === selectedNeuron || connection.userData.to === selectedNeuron) {
                    connection.material.color.setHex(0xffffff);
                    connection.material.opacity = 0.8;
                    
                    // Highlight connected neuron
                    const connectedNeuron = connection.userData.from === selectedNeuron ? 
                        connection.userData.to : connection.userData.from;
                    connectedNeuron.material.color.setHex(0xffff00);
                    connectedNeuron.material.opacity = 1;
                } else {
                    connection.material.color.setHex(0x666666);
                    connection.material.opacity = 0.3;
                }
            });
        }

        function showNeuronDetails(neuron) {
            const details = document.getElementById('neuronDetails');
            const userData = neuron.userData;
            
            details.innerHTML = `
                <strong>üîç Neuron Details</strong><br>
                <strong>Layer:</strong> ${userData.layer.label}<br>
                <strong>Position:</strong> ${userData.neuronIndex + 1} of ${userData.layer.neurons}<br>
                <strong>Activation:</strong> ${userData.activation.toFixed(3)}<br>
                <strong>Role:</strong> ${getNeuronRole(userData)}<br>
                <br>
                <em>This neuron ${getNeuronFunction(userData)}</em>
            `;
            
            document.getElementById('infoPanel').classList.add('show');
        }

        function getNeuronRole(userData) {
            switch(userData.layerIndex) {
                case 0: return "Input Receiver";
                case 1: return "Pattern Detector";
                case 2: return "Decision Maker";
                case 3: return "Final Output";
                default: return "Processor";
            }
        }

        function getNeuronFunction(userData) {
            switch(userData.layerIndex) {
                case 0: return "receives raw data from the outside world.";
                case 1: return "looks for simple patterns and features.";
                case 2: return "combines patterns to make complex decisions.";
                case 3: return "produces the final answer or prediction.";
                default: return "processes information.";
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Auto-rotate when not being controlled
            if (autoRotate && !isAnimating) {
                networkGroup.rotation.y += 0.005;
            }
            
            // Update neuron animations
            updateNeuronAnimations();
            
            renderer.render(scene, camera);
        }

        function updateNeuronAnimations() {
            neurons.flat().forEach(neuron => {
                if (neuron.userData.activation > 0) {
                    // Pulsing effect for active neurons
                    const pulse = Math.sin(Date.now() * 0.01) * 0.1 + 1;
                    neuron.scale.set(pulse, pulse, pulse);
                    
                    // Gradually decrease activation
                    neuron.userData.activation *= 0.98;
                    
                    if (neuron.userData.activation < 0.01) {
                        neuron.userData.activation = 0;
                        neuron.scale.set(1, 1, 1);
                    }
                }
            });
        }

        // Control functions
        function startExploration() {
            document.getElementById('helpText').classList.add('hidden');
            document.getElementById('explanation').classList.add('show');
            autoRotate = true;
        }

        function feedData() {
            if (isAnimating) return;
            isAnimating = true;
            
            updateExplanation("üçé Feeding data into the input layer! Watch how information flows through the network...");
            updateCurrentTask("Processing Input");
            
            // Activate input neurons
            neurons[0].forEach((neuron, index) => {
                setTimeout(() => {
                    neuron.userData.activation = 1;
                    neuron.material.color.setHex(0xffffff);
                    activeNeuronCount++;
                    updateStats();
                }, index * 200);
            });
            
            // Propagate through layers
            setTimeout(() => propagateActivation(1), 800);
        }

        function propagateActivation(layerIndex) {
            if (layerIndex >= layers.length) {
                isAnimating = false;
                updateCurrentTask("Ready");
                updateExplanation("‚úÖ Data processing complete! The network has made its decision based on the input patterns.");
                return;
            }
            
            neurons[layerIndex].forEach((neuron, index) => {
                setTimeout(() => {
                    neuron.userData.activation = Math.random() * 0.8 + 0.2;
                    neuron.material.color.setHex(0xffffff);
                    activeNeuronCount++;
                    updateStats();
                    
                    // Activate connections
                    activateConnections(layerIndex - 1, layerIndex);
                }, index * 100);
            });
            
            setTimeout(() => propagateActivation(layerIndex + 1), 600);
        }

        function activateConnections(fromLayer, toLayer) {
            connections.forEach(connection => {
                const fromNeuron = connection.userData.from;
                const toNeuron = connection.userData.to;
                
                if (fromNeuron.userData.layerIndex === fromLayer && 
                    toNeuron.userData.layerIndex === toLayer) {
                    connection.material.color.setHex(0x00ff00);
                    connection.material.opacity = 0.8;
                    
                    setTimeout(() => {
                        connection.material.color.setHex(0x666666);
                        connection.material.opacity = 0.3;
                    }, 500);
                }
            });
        }

        function startTraining() {
            if (isTraining) return;
            isTraining = true;
            trainingProgress = 0;
            
            updateExplanation("üéØ Training started! The network is learning by adjusting connection strengths. Watch the connections change!");
            updateCurrentTask("Learning Patterns");
            
            const trainingInterval = setInterval(() => {
                trainingProgress += 2;
                currentAccuracy = Math.min(95, trainingProgress * 0.9);
                
                // Randomly adjust connection colors to show learning
                connections.forEach(connection => {
                    if (Math.random() < 0.1) {
                        const weight = connection.userData.weight + (Math.random() - 0.5) * 0.1;
                        connection.userData.weight = Math.max(-1, Math.min(1, weight));
                        
                        // Color based on weight
                        if (weight > 0) {
                            connection.material.color.setHex(0x00ff00);
                        } else {
                            connection.material.color.setHex(0xff0000);
                        }
                        connection.material.opacity = Math.abs(weight) * 0.8;
                        
                        setTimeout(() => {
                            connection.material.color.setHex(0x666666);
                            connection.material.opacity = 0.3;
                        }, 1000);
                    }
                });
                
                updateStats();
                
                if (trainingProgress >= 100) {
                    clearInterval(trainingInterval);
                    isTraining = false;
                    updateCurrentTask("Training Complete");
                    updateExplanation("üéâ Training complete! The network has learned to recognize patterns. The connections now represent learned knowledge!");
                }
            }, 100);
        }

        function showPrediction() {
            if (isAnimating) return;
            
            updateExplanation("üîÆ Making a prediction! The network uses its learned patterns to make a decision about new data.");
            updateCurrentTask("Predicting");
            
            // Reset all neurons first
            neurons.flat().forEach(neuron => {
                neuron.material.color.setHex(neuron.userData.originalColor);
                neuron.material.opacity = 0.8;
                neuron.scale.set(1, 1, 1);
                neuron.userData.activation = 0;
            });
            
            // Simulate prediction flow
            feedData();
        }

        function resetNetwork() {
            isTraining = false;
            isAnimating = false;
            trainingProgress = 0;
            activeNeuronCount = 0;
            currentAccuracy = 0;
            
            // Reset all neurons
            neurons.flat().forEach(neuron => {
                neuron.material.color.setHex(neuron.userData.originalColor);
                neuron.material.opacity = 0.8;
                neuron.scale.set(1, 1, 1);
                neuron.userData.activation = 0;
            });
            
            // Reset connections
            connections.forEach(connection => {
                connection.material.color.setHex(0x666666);
                connection.material.opacity = 0.3;
                connection.userData.weight = Math.random() * 2 - 1;
            });
            
            updateCurrentTask("Ready");
            updateExplanation("üîÑ Network reset! Ready for new learning adventures. Try feeding data or starting training!");
            updateStats();
            autoRotate = true;
        }

        function toggleInfoPanel() {
            const panel = document.getElementById('infoPanel');
            panel.classList.toggle('show');
        }

        function updateStats() {
            document.getElementById('trainingProgress').textContent = Math.round(trainingProgress) + '%';
            document.getElementById('activeNeurons').textContent = activeNeuronCount;
            document.getElementById('accuracy').textContent = Math.round(currentAccuracy) + '%';
        }

        function updateCurrentTask(task) {
            document.getElementById('currentTask').textContent = task;
        }

        function updateExplanation(text) {
            document.getElementById('explanation').innerHTML = text;
            document.getElementById('explanation').classList.add('show');
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            const canvas = document.getElementById('networkCanvas');
            const container = canvas.parentElement;
            
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

        // Initialize when page loads
        window.addEventListener('load', () => {
            setTimeout(initScene, 500);
        });
    </script>
</body>
</html>